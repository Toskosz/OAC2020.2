
2.1

* -O3 tem uma compilação mais direta e simples chegando em alguns casos até a pular passos como por exemplo executar somas por fora do programa e apenas armazenar o resultado 
* -O0 realiza o programa passo a passo sempre começando por alocar espaço na pilha guardando o RA e S0 e por botar o valor inicial da pilha em S0 utilizando como se fosse uma pilha de duas pontas, antes de alterar um valor este é sempre armazenado na pilha
* %hi, %lo ? call printf ? 

2.2 

* Separar .data e .text
* Implementar as funções show, loop1 e fim1 presente em sortc_mod no lugar de show, LBBO_1, LBBO_2, LBBO_3, LBBO4 do sortc.s 
* Completar a função show implementando a convenção de armazenamento da RA e S0 na pilha, armazenar tambem o a0 e a1 e implementar a saída da função isto é: tirar RA e S0 da pilha e aplicar o ret
* Substituir %0 e %1 por a0 e a1
* Botar a main como primeira função
* Trocar o ret em main por ecall de exit

2.3

* Compilar o sortc_mod para cada diretiva de otimização {O0, O1, O2, O3, Os}
* Colocar main como primeira função
* trocar o ret em main por ecall de exit